---
title: 法线变换矩阵
tags: [Computer Graphics]
image: https://i.loli.net/2020/01/31/TWm2EitHznvh3XP.gif
description: 模型光照的计算必然是要用到法线的，一定会有小伙伴和我一样对下面的问题感到疑惑，为什么需要区分模型变换矩阵和法线变换矩阵？二者不可以相同吗？今天我就来给各位小伙伴答疑解惑。法线变换矩阵`gl_NormalMatrix`存在于许多顶点着色器中，本文主讲该矩阵是什么，以及它是怎么来的。
---
模型光照的计算必然是要用到法线的，一定会有小伙伴和我一样对下面的问题感到疑惑，为什么需要区分模型变换矩阵和法线变换矩阵？二者不可以相同吗？今天我就来给各位小伙伴答疑解惑。

法线变换矩阵`gl_NormalMatrix`存在于许多顶点着色器中，本文主讲该矩阵是什么，以及它是怎么来的。文章译自[原文][1]，多有自我理解夹杂其间。

许多计算都是在观察空间`eye space`或者说相机空间`camera space`中完成的。这与照明`lighting`通常是在这个空间进行的事实有关，否则就会受到眼睛位置的影响，例如镜面反射光`specular light`，如果不在观察空间中计算就较难实现。

因此我们需要一种把法线变换到观察空间的方式。为了把一个顶点变换到观察空间，我们是这么写的：

{% highlight factor linenos %}
vertexEyeSpace = gl_ModelViewMatrix * gl_Vertex;
{% endhighlight %}

那我们为什么不对法向量也这么干呢？第一，因为法向量是一个带有3个浮点数的向量，而模型观察矩阵`modelview matrix`是4x4阶的。第二，因为法向量是个向量，它的位置和模我们其实并不关心，我们只想变换它的方向。模型观察矩阵的方向变换部分在于左上角的3x3子矩阵。所以为什么不用这个子矩阵直接和法向量做矩阵乘法呢？

这很容易就能通过下面的代码实现：

{% highlight factor linenos %}
normalEyeSpace = vec3(gl_ModelViewMatrix * vec4(gl_Normal, 0.0));
{% endhighlight %}

所以，`gl_NormalMatrix`只是一种用来简化代码书写或者优化性能的快捷方式吗？并非如此。上面这行代码只在某些情况下能得到正确的变换法线，而非所有情况。

让我们看一看一个潜在的问题：

![origin](https://i.loli.net/2020/01/31/lJmN7kPHZ8np4uf.gif)

上图中的三角形在其斜边上有一条切向量和一条法向量。下图则展示了当模型观察矩阵对图中所有顶点做了不均匀缩放后的结果。

![transformation](https://i.loli.net/2020/01/31/TWm2EitHznvh3XP.gif)

注意：如果缩放是均匀的，那么法线方向会保留下来，模虽然会受影响但很容易通过标准化方式来修正。

上图中的模型观察矩阵不仅用来对所有模型顶点做了变换，还对法线也做了变换，结果显然错了：变换后的法线不再和斜边垂直。

我们知道俩顶点之差代表一条向量。来看斜边切向量，它能由三角形斜边上的两点得出。如果$$P_1$$和$$P_2$$是斜边上的两点，我们可以得到：

{% raw %}
$$T = P_2 - P_1$$
{% endraw %}

现在我们把三维向量$$T$$和三维顶点$$P_1$$，$$P_2$$转换成一个末尾元素为0的四元数，上述等式依然成立，然后两边同时左乘模型观察矩阵：

{% raw %}
$$Modelview \times T = Modelview \times (P_2 - P_1)$$
{% endraw %}

展开：

{% raw %}
$$Modelview \times T = Modelview \times P_2 - Modelview \times P_1$$

$$T' = P_2' - P_1'$$
{% endraw %}

因为$$P_1'$$和$$P_2'$$是变换后的三角形顶点，所以$$T'$$依然是三角形斜边的切向量。但经过模型观察矩阵的变换，斜边的法向量却不再是其法向量了。

我们把考虑向量$$T$$的方法同样地用到$$N$$上面就可以得到两个点$$Q_1$$和$$Q_2$$：

{% raw %}
$$N = Q_2 - Q_1$$
{% endraw %}

现在的主要问题是，变换后的点构成的向量$$N' = Q_2' - Q_1'$$不再和斜边垂直，如上图所示。法向量不再跟斜边切向量一样，由变换后的两点差构成，而是被定义为和斜边垂直的向量。

所以现在我们明白了不能把模型观察矩阵应用到所有法线变换的情况中去。那么问题来了，我们应该应用什么样的矩阵？

考虑一个3x3阶的矩阵$$G$$，假定它就是我们要找的法线变换矩阵的左上角子矩阵，让我们来看看该矩阵是如何把法向量变换成合适的模样的。

因为向量$$T$$和$$N$$垂直，$$T'$$和$$N'$$也垂直，所以它们各自点积为0：
{% raw %}
$$T \cdot N = 0$$

$$T' \cdot N' = 0$$
{% endraw %}

我们设模型观察矩阵左上角的3x3子矩阵为$$M$$，因为$$M$$和$$G$$包含的是对向量$$T$$和$$N$$的方向变换，虽然没有把平移变换也纳入进来，但这并不影响下式成立，可得：
{% raw %}
$$T' \cdot N' = (MT) \cdot (GN) = 0$$
{% endraw %}

我们通常将向量视为列向量，则向量点积$$a \cdot b$$可以转化为矩阵乘法$$a^T \times b$$，所以上式可以做如下转化:
{% raw %}
$$(MT) \cdot (GN) = (MT)^T \times (GN) = T^T M^T G N = 0$$
{% endraw %}

我们已经知道$$T^T \times N = 0$$了，所以要想上式成立只需：
{% raw %}
$$M^T G = E$$
{% endraw %}

其中$$E$$为单位矩阵，所以：
{% raw %}
$$G = (M^T)^{-1}$$
{% endraw %}

综上可知，正确的法线变换矩阵其实是$$M$$的转置的逆再扩展成一个4x4阶矩阵。OpenGL已经为我们计算好并存放在`gl_NormalMatrix`中了。

在文章开头我们就说过，使用模型观察矩阵变换法向量在某些情况下可行，这里的“某些情况”是指那些模型观察矩阵的$$M$$为正交矩阵（orthogonal matrix）[^orthogonal]的情况：
{% raw %}
$$M^{-1} = M^T \Rightarrow G = M$$
{% endraw %}

当两个向量经过左上角为正交矩阵的变换矩阵变换后，它俩的夹角不变。简而言之，该变换矩阵保护向量间的夹角关系。另外，该变换矩阵还保护向量的模。

最后，我们怎么判断模型观察矩阵的$$M$$是不是正交的？其实，当我们的几何操作都限制在旋转和平移中时，例如，在OpenGL中就是只调用`glRotate`和`glTranslate`而不调用`glScale`来处理我们的模型观察矩阵，我们就能确定得到的模型观察矩阵其$$M$$是正交的，是可以做法线变换的。

[^orthogonal]: 正交矩阵就是指那些其逆等于其转置的矩阵，正交矩阵的所有列/行向量都是相互正交的单位向量。

[1]: http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/
